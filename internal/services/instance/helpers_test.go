package instance_test

import (
	"errors"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
	instanceSDK "github.com/scaleway/scaleway-sdk-go/api/instance/v1"
	"github.com/scaleway/scaleway-sdk-go/api/marketplace/v2"
	"github.com/scaleway/terraform-provider-scaleway/v2/internal/acctest"
	"github.com/scaleway/terraform-provider-scaleway/v2/internal/locality"
	"github.com/scaleway/terraform-provider-scaleway/v2/internal/locality/zonal"
	"github.com/scaleway/terraform-provider-scaleway/v2/internal/meta"
	"github.com/scaleway/terraform-provider-scaleway/v2/internal/services/instance"
)

func arePrivateNICsPresent(tt *acctest.TestTools, n string) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		rs, ok := s.RootModule().Resources[n]
		if !ok {
			return fmt.Errorf("resource not found: %s", n)
		}

		instanceAPI, zone, ID, err := instance.NewAPIWithZoneAndID(tt.Meta, rs.Primary.ID)
		if err != nil {
			return err
		}

		res, err := instanceAPI.ListPrivateNICs(&instanceSDK.ListPrivateNICsRequest{ServerID: ID, Zone: zone})
		if err != nil {
			return err
		}

		privateNetworksOnServer := make(map[string]struct{})
		// build current private networks on server
		for _, key := range res.PrivateNics {
			privateNetworksOnServer[key.PrivateNetworkID] = struct{}{}
		}

		privateNetworksToCheckOnSchema := make(map[string]struct{})
		// build terraform private networks
		for key, value := range rs.Primary.Attributes {
			if strings.Contains(key, "pn_id") {
				privateNetworksToCheckOnSchema[locality.ExpandID(value)] = struct{}{}
			}
		}

		// check if private networks are present on server
		for pnKey := range privateNetworksToCheckOnSchema {
			if _, exist := privateNetworksOnServer[pnKey]; !exist {
				return errors.New("private network does not exist")
			}
		}

		return nil
	}
}

var apiGeneratedVolumeNamePrefixes = map[string]string{
	"ubuntu_jammy": "Ubuntu 22.04 Jammy Jellyfish",
	"ubuntu_focal": "Ubuntu 20.04 Focal Fossa",
}

// serverHasNewVolume tests if volume name is generated by terraform
// It is useful as volume should not be set in request when creating an instance from an image
func serverHasNewVolume(_ *acctest.TestTools, n string, image string) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		rs, ok := s.RootModule().Resources[n]
		if !ok {
			return fmt.Errorf("resource not found: %s", n)
		}

		rootVolumeName, ok := rs.Primary.Attributes["root_volume.0.name"]
		if !ok {
			return errors.New("instance root_volume has no name")
		}

		if !strings.HasPrefix(rootVolumeName, apiGeneratedVolumeNamePrefixes[image]) {
			errStr := fmt.Sprintf("unexpected root volume name %q, when it should have been generated by the Instance API, therefore be prefixed by %q", rootVolumeName, apiGeneratedVolumeNamePrefixes[image])
			if strings.HasPrefix(rootVolumeName, "tf-") {
				errStr += " (actual name was generated by the provider)"
			}

			return errors.New(errStr)
		}

		return nil
	}
}

func imageIDMatchLabel(tt *acctest.TestTools, resourceWithImageID, resourceWithImageLabel string, expectMatch bool) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		rs, ok := s.RootModule().Resources[resourceWithImageID]
		if !ok {
			return fmt.Errorf("resource was not found: %s", resourceWithImageID)
		}

		zonedImageID := zonal.ExpandID(rs.Primary.Attributes["image"])
		expectedImageID := zonedImageID.ID
		zone := zonedImageID.Zone
		commercialType := rs.Primary.Attributes["type"]

		rs, ok = s.RootModule().Resources[resourceWithImageLabel]
		if !ok {
			return fmt.Errorf("resource was not found: %s", resourceWithImageLabel)
		}

		imageLabel := rs.Primary.Attributes["image"]

		client := meta.ExtractScwClient(tt.Meta)
		api := marketplace.NewAPI(client)

		localImageIDFromLabel, err := api.GetLocalImageByLabel(&marketplace.GetLocalImageByLabelRequest{
			ImageLabel:     imageLabel,
			Zone:           zone,
			CommercialType: commercialType,
			Type:           marketplaceImageType,
		})
		if err != nil {
			return fmt.Errorf("failed to get local image by label: %w", err)
		}

		if expectMatch && expectedImageID != localImageIDFromLabel.ID {
			return fmt.Errorf("unexpected image ID for label %q: expected %s, got %s", imageLabel, expectedImageID, localImageIDFromLabel.ID)
		} else if !expectMatch && expectedImageID == localImageIDFromLabel.ID {
			return errors.New("images IDs match when they should not")
		}

		return nil
	}
}
